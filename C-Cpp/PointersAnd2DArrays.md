# 【小记】与指针和二维数组过几招

在C/C++中有个叫指针的玩意存在感极其强烈，而说到指针又不得不提到内存管理。现在时不时能听到一些朋友说指针很难，实际上说的是内存操作和管理方面的难。  

最近在写C程序使用指针的时候遇到了几个让我印象深刻的地方，这里记录一下，以便今后回顾。

![embarrassed-2022-05-06](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/embarrassed-2022-05-06.png)  

> “经一蹶者长一智，今日之失，未必不为后日之得。” - 王阳明《与薛尚谦书》  

## 指针和二级指针  

简述下指针的概念。  

### 指针

一个指针可以理解为一条**内存地址**。  

![pointer-2022-05-06](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/pointer-2022-05-06.jpg)  

> 这里先定义了一个整型变量`test`，接着用取址运算符`&`取得这个变量的内存地址并打印出来。  
> 可以看到该变量的内存地址是`000000000061FE1C`

### 指针变量  

指针变量就是存放**指针**（也就是存放内存地址）的变量，使用`数据类型* 变量名`进行定义。  

值得注意的是指针变量内储存的指针（内存地址）**所代表的变量的**数据类型，比如`int*`定义的指针变量就只能指向`int`类型的变量。

```c
int test = 233;
int* ptr = &test;
```  

> `test`**变量**的类型是整型`int`，所以`test`存放的就是一个整形数据。  
> 而`ptr`**变量**的类型是整型指针类型`int*`，存放则的是**整性变量**`test`的指针（内存地址）。

### 二级指针  

二级指针指的是**一级指针变量**的地址。  

```c
int main() {
    int test = 233;
    printf("%p\n", &test);
    int *ptr = &test;
    printf("%p", &ptr);
    return 0;
}
/* stdout
000000000061FE1C
000000000061FE10
*/
```

> 这个例子中二级指针就是`ptr`变量的地址`000000000061FE10`。  

### 二级指针变量  

二级指针变量就是存放**二级指针**（二级指针的地址）的变量，使用`数据类型** 变量名`进行定义。   

```c
int main() {
    int test = 233;
    int *ptr = &test;
    int **ptr2 = &ptr;
    return 0;
}
```

> `ptr`**变量**的类型是整型指针类型`int*`，存放的是**整性(`int`)变量**```test```的指针（内存地址），  
> `ptr2`**变量**的类型是二级整型指针类型`int**`，存放的是**整性指针(`int*`)变量**`ptr`的内存地址。  

![doublePointerGraph-2022-05-06](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/doublePointerGraph-2022-05-06.png)

### 多级指针变量  

虽然二级以上的指针变量相对来说不太常用，但我觉得基本的辨别方法还是得会的：

通过观察发现，指针变量的数据类型定义其实就是在**其所指向的数据类型名后加一个星号**，  
比如说：  

* 指针`ptr`指向整型变量`int test`，那么它的定义写法就是`int* ptr`。（数据类型在`int`后加了一个星号）  

* 指针`ptr2`指向一级指针变量`int* ptr`，那么它的定义写法就是`int** ptr2`。（数据类型在`int*`后加了一个星号）

再三级指针变量`int*** ptr3`，乍一看星号这么多，实际上“剥”一层下来就真相大白了：  

```(int**)*```  

实际上三级指针变量指向的就是**二级指针变量的地址**。  

![008-2022-05-06](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/008-2022-05-06.png)

其他更多级的指针变量可以依此类推。  

## 栈内存和堆内存  

指针和内存操作关系紧密，提到指针总是令人情不自禁地想起内存。  

程序运行时占用的内存空间会被划分为几个区域，其中和这篇笔记息息相关的便是**栈区(Stack)**和**堆区(Heap)**。  

### 栈区 (Stack)  

栈区的操作方式正如数据结构中的栈，是**LIFO后进先出**的。这种操作模式的一个很经典的应用就是**递归函数**了。  

每个函数被调用时需要从**栈区**划分出一块栈内存用来存放调用相关的信息，这块栈内存被称为函数的**栈帧**。

-------

**栈帧**存放的内容**主要是**（按入栈次序由先至后）：

1. 返回地址，也就是**函数被调用处**的下一条指令的内存地址（内存中专门有代码区用于存放），用于函数调用结束返回时能接着原来的位置执行下去。  

2. 函数调用时的**参数值**。

3. 函数调用过程中定义的**局部变量**的值。

4. and so on...  

由LIFO后进先出可知一次函数调用完毕后相较而言**局部变量**先出栈，接着是**参数值**，最后栈顶指针指向**返回地址**，函数返回，接着下一条指令执行下去。  

-------


**栈区**的特性：

1. 交由系统（C语言这儿就是编译器参与实现）**自动分配和释放**，这点在函数调用中体现的很明显。  

2. **分配速度较快**，但并不受程序员控制。

3. 相对来说空间较小，如果申请的空间大于栈剩余的内存空间，会引发**栈溢出**问题。（栈内存大小限制因操作系统而异）  

    > 比如递归函数控制不当就会导致栈溢出问题，因为每层函数调用都会形成新的栈帧“压到”栈上，如果递归函数层数过高，栈帧迟迟得不到“弹出”，就很容易挤**爆栈**内存。  

4. **栈内存占用大小**随着函数调用层级升高而**增大**，随着函数调用结束逐层返回而**减小**；也随着**局部变量**的定义而增大，随着局部变量的销毁而减小。   

    > 栈内存中储存的数据的**生命周期**很清晰明确。

5. 栈区是一片**连续的**内存区域。

-------

### 堆区 (Heap)

堆内存就真的是“一堆”内存，值得一提的是，这里的堆**和数据结构中的堆没有关系**。  

相对栈区来说，堆区可以说是一个更加灵活的大内存区，支持按需进行动态分配。

------

**堆区**的特性：  

1. 交由**程序员或者垃圾回收机制进行管理**，如果不加以回收，在整个程序没有运行完前，分配的堆内存会一直存在。（这也是容易造成内存泄漏的地方）  

    > 在C/C++中，堆内存需要程序员**手动申请分配和回收**。  

2. 分配速度**较慢**，系统需要依照算法搜索（链表）足够的内存区域以分配。  

3. 堆区**空间比较大**，只要还有可用的物理内存就可以持续申请。  

4. 堆区是**不连续（离散）的**内存区域。（大概是依赖**链表**来进行分配操作的） 
 
5. 现代操作系统中，在程序运行完后会**回收**掉所有的堆内存。  

    > 要养成不用就释放的习惯，不然运行过程中进程占用内存可能越来越大。 

-------

## 简述C中堆内存的分配与释放

### 分配

这里咱就直接报菜名吧!  

![alloc-2022-05-07](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/alloc-2022-05-07.png)  

这一部分的函数的原型都定义在头文件`stdlib.h`中。  

1. `void* malloc(size_t size)`  

    用于请求系统从**堆区**中分配一段**连续的内存块**。  

2. `void* calloc(size_t n, size_t size);`  

    在和`malloc`一样申请到连续的内存块后，将所有分配的内存全部**初始化为0**。  

3. `void* realloc(void* block, size_t size)`

    **修改**已经分配的内存块的大小（具体实现是重新分配），可以放大也可以缩小。  

> `malloc`可以记成`Memory Allocate 分配内存`；  
> `calloc`可以记成`Clear and Allocate 分配并设置内存为0`；  
> `realloc`可以记成`Re-Allocate 重分配内存`。  

------

简单来说原理大概是这样：  

* `malloc`内存分配依赖的数据结构是**链表**。简单说来就是所有空闲的内存块会被组织成一个**空闲内存块链表**。  

* 当要使用`malloc`分配内存时，它首先会依据算法扫描这个链表，直到找到**一个大小满足需求**的空闲内存块为止，然后将这个空闲内存块传递给用户（通过指针）。  
（如果这块的大小**大于**用户所请求的内存大小，则将多余部分“切出来”接回链表中）。  

* 在不断的分配与释放过程中，由于内存块的“切割”，大块的内存可能逐渐被切成许多小块内存存在链表中，这些便是**内存碎片**。当`malloc`找不到合适大小的内存块时便会尝试**合并这些内存碎片**以获得大块空闲的内存。  

* 实在找不到空闲内存块的情况下，`malloc`会返回`NULL`指针。  

-------

### 释放

释放手动分配的堆内存需要用到`free`函数：  

```void free(void* block)```  

只需要传入**指向分配内存始址**的指针变量作为实参传入即可。  

> 在`C/C++`中，对于**手动申请分配的堆内存**在使用完后一定要及时释放，  
> 不然在运行过程中进程占用内存**可能会越来越大**，也就是所谓的内存泄漏。  

> 不过在现代操作系统中，程序运行完毕后OS会自动回收对应进程的内存，**包括泄露的内存**。内存泄露指的是在程序运行过程中**无法操作的内存**。  

--------

`free`为什么知道申请的内存块大小？  

![allocatedMem-2022-05-07](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/allocatedMem-2022-05-07.png)  

简单来说，就是在`malloc`进行内存分配时会把内存大小**分配地略大一点**，多余的内存部分用于储存一些头部数据（这块内存块的信息），这块头部数据内就**包括分配的内存的长度**。  

但是在返回**指针**的时候，`malloc`会将其**往后移动**，使得指针代表的是**用户请求的内存块的起始地址**。  

**头部数据**占用的大小通常是**固定的**（网上查了一下有一种说法是`16`字节，也有说是`sizeof(size_t)`的），在将指针传入`free`后，`free`会将指针**向前移动**指定长度以获得头部数据，读取到**分配的内存长度**，然后**连同头部数据和所分配长度的内存一并释放掉**。  

内存释放可以理解为**这块内存被重新接到了空闲链表上**，以备后面的分配。  
（实际上内存释放后的情况其实挺复杂的，得要看具体的算法实现和运行环境）  

------

## 二维数组

### 定义和初始化

C语言中二维数组的定义：  

```数据类型 数组名[行数][列数];```  

初始化则可以使用**大括号**：  

```c
int a[3][4]={
    {1,2,3,4},
    {5,6,7,8},
    {9,10,11,12}
};

int b[3][4]={ // 内层不要大括号也是可以的，具体为什么后面再说
    1,2,3,4,
    5,6,7,8,
    9,10,11,12  
};

char str[2][6]={
    "Hello",
    "World"
};

```

此外，在**有初始化值**的情况下，定义二维数组时的一维长度（行数）是**可以省略**的：  

```c
int a[][4]={ // 如果没有初始化，则一维长度不可省略
    1,2,3,4,
    5,6,7,8,
    9,10,11,12  
}
```

### 在内存中

按上述语句定义的数组，在进程内存中一般储存于：

1. **栈区** - 在函数内部定义的**局部**数组变量。  

2. **静态储存区** - 当用`static`修饰数组变量或者在**全局作用域**中定义数组。  

数组在内存中是**连续**且呈**线性储存的**，**二维数组也是不例外的**。  

虽然在使用过程中二维数组发挥的是“二维”的功能，但其在内存中是被映射为一维线性结构进行储存的。  

实践验证一下：  

```c
int i, j;
int a[][4] = { // 如果没有初始化，则一维长度不可省略
        1, 2, 3, 4,
        5, 6, 7, 8,
        9, 10, 11, 12
};
size_t len1 = sizeof(a) / sizeof(a[0]);
size_t len2 = sizeof(a[0]) / sizeof(a[0][0]);
for (i = 0; i < len1; i++) {
    for (j = 0; j < len2; j++)
        printf(" [%d]%p ", a[i][j], &a[i][j]);
    printf("\n");
}
```  

输出：  

![continuousArr-2022-05-08](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/continuousArr-2022-05-08.jpg)  

第一维有**3行**，第二维有**4列**。

一个`int`类型数据占用`4`个字节，从上面的图可以看出来：  

* `[1]000000000061FDD0` -> `[2]000000000061FDD4` 相隔4字节，说明这两个数组元素相邻，同一行中数组元素储存连续。  

* `[4]000000000061FDDC` -> `[5]000000000061FDE0` 同样相隔4字节，这两个数组元素在内存中也是相邻的。  

* 从`[1]000000000061FDD0`到`[12]000000000061FDFC`正好相差`44`个字节，整个二维数组元素在内存中是**连续储存**的。  

-------

这样一看，为什么**定义并初始化**的时候**二维数组**的第一维可以省略已经不言而喻了：  

在初始化的时候编译器通过数组**第二维**的大小对元素进行“分组”，每一组可以看作是一个一维数组，这些一维数组在内存中从低地址到高地址连续排列储存形成二维数组：

![memOf2DArr-2022-05-08](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/memOf2DArr-2022-05-08.png)  

> 在上面例子中大括号中的元素`{1,2,3,4,5,6,7,8,9,10,11,12}`被按第二维长度`4`划分成了`{1,2,3,4}`，`{5,6,7,8}`，`{9,10,11,12}`三组，这样程序也能知道第一维数组长度为`3`了。  


## 相关文章

[逆向基础笔记：汇编二维数组 - 52pojie论坛](https://www.52pojie.cn/thread-1384913-1-1.html)  
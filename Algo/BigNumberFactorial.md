# 【题解笔记】PTA基础6-10：阶乘计算升级版  

题目地址：https://pintia.cn/problem-sets/14/problems/742  

## 前言

咱目前还只能说是个小白，写题解是为了后面自己能够回顾。如果有哪些写错的/能优化的地方，也请各位多指教。( •̀ ω •́ )

## 题目描述

本题要求实现一个打印非负整数阶乘的函数，要求能处理**一定大数值的阶乘**。

<details>
<summary>展开查看详情</summary>

### 函数接口定义

```c
void Print_Factorial ( const int N );
```

其中`N`是用户传入的参数，其值**不超过1000**。如果`N`是非负整数，则该函数必须在一行中打印出N!的值，否则打印`"Invalid input"`。

### 裁判测试程序样例

```c
#include <stdio.h>

void Print_Factorial ( const int N );

int main()
{
    int N;
    
    scanf("%d", &N);
    Print_Factorial(N);
    return 0;
}

/* 你的代码将被嵌在这里 */
```

### 输入样例

```
15
```

### 输出样例

```
1307674368000
```

### 限制

|限制内容|限制条件|
|:---:|:---:|
|代码长度限制|16 KB|
|时间限制|400 ms|
|空间限制|64 MB|

</details>

## 想法

### 怎么储存如此之大的阶乘结果

不看不知道，细看吓一跳，题目中对`N`的限制是`0<=N<=1000`，得想个办法让程序储存`1000!`这么大的一个数。

扫视了一圈C语言的基本数据类型，就连`unsigned long long`类型也远存不下1000的阶乘。

转换一下思路。数字每一位之间都是紧挨在一起的，我们其实可以采用一种连续的数据结构来储存这个结果，比如....数组！

设数组**第一个元素表示个位**，**第二个元素表示十位**...以此类推。这样一来，我们就可以用数组**以数位升序**来储存这个大数了。最后只需将数组中的每个元素(`int`)打印到屏幕上即可。  

### 给数组分配多少个元素

题目的裁判测试程序并没有引入`stdlib.h`头文件，因此我没法使用动态内存分配/回收函数。而`1000!`的结果到底有多少位，我一时半会儿也是不知道的。  

其实可以用最**简单粗暴**的方式估计一下：`1000`个`1000`相乘

$$1\times 10^{3}\times 10^{3} \cdots \times 10^{3} = 1\times 10^{3\times1000}$$

这样算出来的结果有`3001`位。如果是运算`1000!`的话，是怎么也不会算出`3001`个数位的数字的，所以分配`3000`个元素一定能保证数组能装得下结果的所有数位。

> 注：有一种可以用来计算阶乘近似值的公式——**斯特林公式**

### 实现乘法时关注的对象

阶乘运算的基础是乘法运算，只要把正确的乘法算法写出来，这道题咱们就几乎能解决了！  

关于乘法算法，我觉得要关注以下三种情况：

1. 无需进行进位操作

    ![Basic-6-10-1-2022-09-03](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/Basic-6-10-1-2022-09-03.png)  

    每一位数字乘上因数后均未超过`9`，无需进位。

2. 需要进行进位操作

    ![Basic-6-10-2-2022-09-03](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/Basic-6-10-2-2022-09-03.png)  

    **假设当前处理的是十位**，十位数字乘上因数后为`12`，超过了`9`。将`12`“**拆成**”`1`和`2`，将**最低位**`2`保留下来，其余的数位`1`**进入高位**。  

3. 需要进行进位操作，进了一位后的高位又可以再进一位

    ![Basic-6-10-3-2022-09-03](https://raw.githubusercontent.com/cat-note/bottleassets/main/img/Basic-6-10-3-2022-09-03.png)  

    **假设当前处理的是百位**，百位数字乘上因数后为`49`，超过了`9`。将`49`“**拆成**”`4`和`9`，将**最低位**`9`保留下来，其余的数位`4`**进入高位**。
    
    然而此时发现，之前在处理十位时，十位上的数字被拆分为`1`和`4`，其中`1`进入到百位，而百位现在的数字是`9`，`9+1`**又可以向后进一位**。

    `9+1=10`，因此将`0`保留下来，而`1`**进入高位**，加上之前进入高位的数字`4`，现在进入高位的数字是`4+1=5`。

    > 注：这是**很容易被忽略**的一种情况。

根据以上描述，可以发现在**每次迭代**中，我关注的是：  

1. **当前处理的数位**
2. **进入到下一位的数值**

### 处理乘法中的进位

上面给出的演示中，进入高位的数字都没有超过`9`，那么如果要进入高位的数字超过了`9`怎么办呢？  



写一下怎么对待进位：进行累积
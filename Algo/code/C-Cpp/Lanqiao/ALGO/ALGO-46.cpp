#include <iostream>

using namespace std;

int main()
{
    int N, M;
    cin >> N >> M;
    int groups = N / M; // 盘子能被分成几组
    if (N % M != 0)
        groups++;
    // 每组看作一个盘子，因为每组的盘子可以一起移动
    cout << (1 << (groups)) - 1;
    return 0;
}
/*
    计算汉诺塔的移动次数时有个公式:

        设起始柱上有n个盘子，那么把盘子全移动到目标柱需要【2^n-1】步。

    本题的题目已经提示的很详细了，可以同时移动M个盘子，那就把M个盘子看成一个整体。

        N=5，M=2的情况，5个盘子可以被分成三组: 2 2 1，因此就可以看作【汉诺塔起始只有3个盘子】
    --------------------
    因为公式中正好要求2的n次方，这里我直接用位运算解决了: 1<<n 相当于 pow(2,n)

        - SomeBottle 2023.1.13
*/
/*
题目 1594: 蓝桥杯算法训练VIP-Hanoi问题
    时间限制: 1s 内存限制: 128MB 提交: 183 解决: 133
题目描述
    如果将课本上的Hanoi塔问题稍做修改：仍然是给定N只盘子，3根柱子，但是允许每次最多移动相邻的M只盘子（当然移动盘子的数目也可以小于M）,最少需要多少次？
    例如N=5，M=2时，可以分别将最小的2个盘子、中间的2个盘子以及最大的一个盘子分别看作一个整体，这样可以转变为N=3，M=1的情况，共需要移动7次。
输入格式
    输入数据仅有一行，包括两个数N和M（0<=M<=N<=8）
输出格式
    仅输出一个数，表示需要移动的最少次数
样例输入
    5 2
样例输出
    7
*/
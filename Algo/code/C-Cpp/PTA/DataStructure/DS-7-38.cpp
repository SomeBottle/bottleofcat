#include <cstdio>
#include <vector>
#include <queue>

using namespace std;

int main()
{
    priority_queue<long, vector<long>, greater<long>> pq; // 长整型优先队列(小根堆)
    int N, M;
    scanf("%d %d", &N, &M);
    for (int i = 0; i < N; i++)
    {
        long num;
        scanf("%ld", &num);
        if (i < M)
        {
            // 先把前M个数加入小根堆中
            pq.push(num);
        }
        else if (num > pq.top())
        {
            // 剩余的数如果有比堆顶大的
            // 就弹出堆顶，把这个更大的数加入堆
            pq.pop();
            pq.push(num);
        }
    }
    // 输出堆中所有内容
    long stk[10];   // 简易栈
    int stkTop = 0; // 栈顶
    // 因为是小根堆，输出的时候是升序的，而题目需要降序，这里用vector做个简易栈
    while (!pq.empty())
    {
        stk[stkTop++] = pq.top();
        pq.pop();
    }
    // 倒着输出
    for (int i = stkTop - 1; i >= 0; i--)
    {
        printf("%ld", stk[i]);
        if (i != 0)
            printf(" ");
    }
}

/*
    看到题目中的“找出前M位”，且给的数据规模可能很大，就说明这题比较适合【堆排序】了。

        * 这类问题应该叫“TopK”问题来着

        * 本题依靠快排也能解决，单纯的堆排序也能解决，但实际上还能进一步优化。

    以下是最大规模数据(10^6个)下的三种解法的运行耗时:

        - 快速排序 220+ ms
        - 大根堆排序 110+ ms
        - 优化的大根堆排序 90~105ms

    前两种方式是先把整个序列排好序再取出前M位，思路很简单粗暴。
    --------------------------
    这个题解中我用了最后一种思路:

        1. 准备一个优先队列(小根堆实现)

        2. 先读入【M个数字】存入优先队列

        3. (如果还剩有数字)读入【剩余的N-M个数字】，每读入一个数字就【和优先队列堆顶数字进行比较】:

            - 如果新读入的数字比堆顶要更大，就【弹出堆顶】，【将新数字加入优先队列中】。

            - 这样全程维持【优先队列中存放着M个最大的数】

        4. 读完数字后，逆向输出优先队列中的值即可(借助栈)

            * 因为题目要求以非递减的形式输出

    相比把所有数字都读入优先队列进行排序，这种优化的写法只在必要的时候对优先队列进行操作，节省了一定的开销。

        - SomeBottle 2023.1.28

*/
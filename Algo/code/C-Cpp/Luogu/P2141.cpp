#include <cstdio>
#include <cstring>

using namespace std;

int main()
{
    int N;
    scanf("%d", &N);
    bool sums[20001]; // 题目两正整数相加不会超过20000，在这里储存每个和是否出现
    int nums[100];    // 储存N个整数
    memset(sums, 0, sizeof(sums));
    // 读入数据，顺带求个和
    for (int i = 0; i < N; i++)
    {
        scanf("%d", &nums[i]);
        if (i > 0)
        {
            // 将当前数字和之前读入的所有数值都求一次和，然后将和作为下标访问sums，用sums标记【每个和是否出现】
            for (int j = i - 1; j >= 0; j--)
                sums[nums[i] + nums[j]] = true;
        }
    }
    // 扫描一遍序列，判断每个序列中的数字【是否作为和出现】即可
    int cnt = 0;
    for (int i = 0; i < N; i++)
    {
        if (sums[nums[i]])
            cnt++;
    }
    printf("%d", cnt);
    return 0;
}

/*
    题目求的是“其中有多少个数，恰好等于集合中另外两个（不同的）数之和”

    可以发现，只需要判断序列中的每个数【是否作为一个和】出现即可。

        - 题目中的数字均为正整数，且每个正整数最大值为10000，因此两个正整数相加的最大值为20000

        - 我完全可以用一个包含20000个元素的数组对【某个数是否作为两数之和出现】进行标记

    因此我的做法是，在读入数据时将【当前的数字】分别和【前面读入的所有数字相加】得到一个和，每得到一个和，就将其作为下标来随机访问【标记数组sums】以进行标记。

    最后扫描一遍数字序列，将数字作为下标来访问【标记数组sums】，统计作为和出现的数字的数量即可。

        - SomeBottle 2023.2.20
*/